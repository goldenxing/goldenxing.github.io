{"pages":[{"title":"tags","text":"mysql","path":"tags/index.html"},{"title":"categories","text":"数据库","path":"categories/index.html"}],"posts":[{"title":"JAVA快速排序","text":"&emsp;&emsp;快速排序是较为常见的算法之一，快速排序在实际排序应用中也是最好的选择，因为它的平均性能非常好，它的期望复杂度为nlgn，另外，它还是一种稳定的排序方法。快速排序利用分治思想，将待排序数组分成左右两个部分，然后对其分别递归调用快速排序算法。 下面通过一个例子介绍快速排序算法的思想，假设要对数组a[10]={6，1，2，7，9，3，4，5，10，8}进行排序，首先要在数组中选择一个数作为基准值，这个数可以随意选择，在这里，我们选择数组的第一个元素a[0]=6作为基准值，接下来，我们需要把数组中小于6的数放在左边，大于6的数放在右边，怎么实现呢？ 我们设置两个“哨兵”，记为“哨兵i”和“哨兵j”，他们分别指向数组的第一个元素和最后一个元素，即i=0，j=9。首先哨兵j开始出动，哨兵j一步一步地向左挪动（即j–），直到找到一个小于6的数停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于6的数停下来。 最后哨兵j停在了数字5面前，哨兵i停在了数字7面前。此时就需要交换i和j指向的元素的值。 交换之后的数组变为a[10]={6，1，2，5，9，3，4，7，10，8} 第一次交换至此结束。接下来，由于哨兵i和哨兵j还没有相遇，于是哨兵j继续向前，发现比6小的4之后停下；哨兵i继续向前，发现比6大的9之后停下，两者再进行交换。交换之后的数组变为a[10]={6，1，2，5，4，3，9，7，10，8}。 第二次交换至此结束。接下来，哨兵j继续向前，发小比6小的3停下来；哨兵i继续向前，发现i==j了！！！于是，这一轮的探测就要结束了，此时交换a[i]与基准的值，数组a就以6为分界线，分成了小于6和大于6的左右两部分：a[10]={3，1，2，5，4，6，9，7，10，8}。 至此，第一轮快速排序完全结束，接下来，对于6左边的半部分3，1，2，5，4，执行以上过程；对于6右边的半部分9，7，10，8，执行以上过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列：1 2 3 4 5 6 7 8 9 10，到此，排序完全结束。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 public class QuickSort &#123; public QuickSort() &#123; // TODO Auto-generated constructor stub &#125; private static void sort(int[] a, int low, int high )&#123; int i = low; int j = high; int temp = a[low]; if(i &gt;=j)&#123; return; &#125; while(i != j)&#123; while(a[j] &gt;= temp &amp;&amp; j&gt;i)&#123; j--; &#125; while(a[i] &lt;= temp &amp;&amp; i&lt;j)&#123; i++; &#125; if(i &lt; j)&#123; int flag = a[i]; a[i] = a[j]; a[j] = flag;// System.out.println(a[i]+&quot;--&quot;+a[j]+&quot;交换&quot;); &#125; &#125; int flag2 = a[low]; a[low] = a[i]; a[i] = flag2; sort(a, low, i-1); sort(a, i+1, high); &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub int a[] = new int[]&#123; 1,4,7,2,3,6,5,8 &#125;; sort(a, 0, 7); for(int k : a)&#123; System.out.println(k); &#125; &#125;&#125;","path":"2019/03/29/JAVA快速排序/"},{"title":"JAVA多线程与内部类","text":"今天利用多线程优化日志保存速度时发现对于多线程的一些知识有些遗忘和一些问题，写下博客记录备忘。首先是多线程的创建问题，常用的两种方法创建多线程。 1. 继承Thread类步骤：①、定义类继承Thread； ②、复写Thread类中的run方法；目的：将自定义代码存储在run方法，让线程运行 ③、调用线程的start方法：该方法有两步：启动线程，调用run方法。&emsp;&emsp;如图为利用线程进行utm日志的存储 2. 实现Runnable接口&emsp;&emsp;&emsp;①、定义类实现Runnable接口 &emsp;&emsp;&emsp;②、覆盖Runnable接口中的run方法将线程要运行的代码放在该run方法中。 &emsp;&emsp;&emsp;③、通过Thread类建立线程对象。 &emsp;&emsp;&emsp;④、将Runnable接口的子类对象作为实际参数传递给Thread类的构造函数。自定义的run方法所属的对象是Runnable接口的子类对象。所以要让线程执行指定对象的run方法就要先明确run方法所属对象 &emsp;&emsp;&emsp;⑤、调用Thread类的start方法开启线程并调用Runnable接口子类的run方法。 &emsp;&emsp;&emsp;如图示，涉及公司代码参数部分已打码~~ &emsp;&emsp;&emsp;先来说说今天遇到的问题，在多线程的使用过程中，因为线程相当于内部类，所以在调用外部类参数是出现了报错，让我在参数定义时加上fianl修饰，","path":"2019/03/18/JAVA多线程与内部类/"},{"title":"MySQL中利用索引优化","text":"一、关于索引 索引顾名思义就是检索、指引，就像一本书的目录一样，当我们根据条件查询而没有索引时数据库就会进行全表扫描，也就是一个一个进行查找，如果数据量很少那么不会影响么，但咱们的目标不都是处理千万级甚至上亿级别数据的高端程序员嘛（码畜也要有目标不是），如果没有索引，那么在超大数据量的查询操作中一条数据可能会花费10几秒的时间，这在当前的社会是不被允许的。 二、索引的类别和语法索引的类别：mysql中的常用索引有三种：主键索引、普通索引、聚合索引。 主键索引：主键索引就是加在主键上的索引，一般在建表设置主键时会自动创建索引。 普通索引： 创建在非主键列上的索引。 聚合索引： 创建在N个列上的索引。 索引的语法：创建普通索引：ALTER TABLE 表名 ADD INDEX 索引名 (加索引的列)创建聚合索引：ALTER TABLE 表名 ADD INDEX 索引名 (加索引的列1,加索引的列2)查看某张表的索引：SHOW INDEX FROM 表名；删除某张表的索引：DROP INDEX 索引名 ON 表名; 三、实际操作纸上得来终觉浅，绝知此事要躬行。废话少说，先建一张千万条数据的表。先创建一张表: 12345678 DROP TABLE IF EXISTS `test_user`; CREATE TABLE `test_user` ( `id` bigint(20) PRIMARY key not null AUTO_INCREMENT, `username` varchar(50) DEFAULT NULL, `email` varchar(30) DEFAULT NULL, `password` varchar(32) DEFAULT NULL, `status` tinyint(1) NULL DEFAULT 0) ENGINE=MyISAM DEFAULT CHARSET=utf8; ENGINE 用MyISAM是因为它的插入速度快，毕竟是千万级。。。然后利用存储过程插入一千万的数据（这个不大了解copy来的，有时间弄弄）: 123456789 create procedure demo()begin declare num int; set num=1; while num &lt;= 10000000 do insert into test_user(username,email,password) values(CONCAT(&apos;username_&apos;,num), CONCAT(num ,&apos;@qq.com&apos;), MD5(num)); set num=num+1; end while; end 然后执行存储过程 call demo();等待程序运行完毕，你就能获得一张内含千万级数据的表啦。得到表之后我们先来运行下查询语句看看时间： SELECT id,username,email,password FROM test_user WHERE id=9999987 因为建表时将id设为了主键，所以在根据id查找时用了主键索引，所以速度很快。 我们再来执行SELECT id,username,email,password FROM test_user WHERE username=’username_9000000’耗时：4.613s。 Extra显示数据库运用了全表扫描所以速度慢，我们把username列加上索引试试。运行:ALTER TABLE test_user ADD INDEX index_name(username)。 我不知道为什么我的索引加的贼慢，老大说这个跟硬件、数据库版本等都有关系，可能是公司电脑不好吧，正常二三百秒应该就可以了，接下来再根据用户名来进行查询:select id,username,email,password from test_user where username=’username_9000000’。 结果仅用了0.02S相对于加索引前的4.61S快了将近230倍！！！我们再用Extra分析看看: EXPLAIN SELECT * from test_user where username=’username_9999999’ Extra显示，我们的本次查询使用了username的索引，仅扫描了将近5000行便查询出了结果，查询速度得到了质的提升。 再来试试用两个条件联合查询:SELECT * FROM test_user WHERE password = ‘1dfb5fe87af0d26015808b2a431360a6’ AND username = ‘username_9999014’。 运行结果0.027S，根据Extra显示，我们使用了索引搜索。说明数据库会优先匹配索引来进行查找。 我们再执行:SELECT * FROM test_user WHERE password = ‘41c3d2dc43de0e942f43000f0767cf95’ OR username = ‘username_9999015’，虽然我们对username列加了索引，但是password列没有加，当索引执行password的搜索时，就会进行全表搜索速度变慢。 可以看到OR语句搜索时没有使用索引，而是进行了全表搜索，搜索速度下降很多。AND语句才会使用聚合索引，要符合最左原则。 小结： 合理使用索引可以极大加快查询速度 sql编写过程中慎用OR条件","path":"2019/03/04/MySQL中利用索引优化/"}]}