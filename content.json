{"pages":[{"title":"categories","text":"数据库","path":"categories/index.html"},{"title":"tags","text":"mysql","path":"tags/index.html"}],"posts":[{"title":"MySQL中利用索引优化","text":"一、关于索引 索引顾名思义就是检索、指引，就像一本书的目录一样，当我们根据条件查询而没有索引时数据库就会进行全表扫描，也就是一个一个进行查找，如果数据量很少那么不会影响么，但咱们的目标不都是处理千万级甚至上亿级别数据的高端程序员嘛（码畜也要有目标不是），如果没有索引，那么在超大数据量的查询操作中一条数据可能会花费10几秒的时间，这在当前的社会是不被允许的。 二、索引的类别和语法索引的类别：mysql中的常用索引有三种：主键索引、普通索引、聚合索引。 主键索引：主键索引就是加在主键上的索引，一般在建表设置主键时会自动创建索引。 普通索引： 创建在非主键列上的索引。 聚合索引： 创建在N个列上的索引。 索引的语法：创建普通索引：ALTER TABLE 表名 ADD INDEX 索引名 (加索引的列)创建聚合索引：ALTER TABLE 表名 ADD INDEX 索引名 (加索引的列1,加索引的列2)查看某张表的索引：SHOW INDEX FROM 表名；删除某张表的索引：DROP INDEX 索引名 ON 表名; 三、实际操作纸上得来终觉浅，绝知此事要躬行。废话少说，先建一张千万条数据的表。先创建一张表: 12345678 DROP TABLE IF EXISTS `test_user`; CREATE TABLE `test_user` ( `id` bigint(20) PRIMARY key not null AUTO_INCREMENT, `username` varchar(50) DEFAULT NULL, `email` varchar(30) DEFAULT NULL, `password` varchar(32) DEFAULT NULL, `status` tinyint(1) NULL DEFAULT 0) ENGINE=MyISAM DEFAULT CHARSET=utf8; ENGINE 用MyISAM是因为它的插入速度快，毕竟是千万级。。。然后利用存储过程插入一千万的数据（这个不大了解copy来的，有时间弄弄）: 123456789 create procedure demo()begin declare num int; set num=1; while num &lt;= 10000000 do insert into test_user(username,email,password) values(CONCAT(&apos;username_&apos;,num), CONCAT(num ,&apos;@qq.com&apos;), MD5(num)); set num=num+1; end while; end 然后执行存储过程 call demo();等待程序运行完毕，你就能获得一张内含千万级数据的表啦。得到表之后我们先来运行下查询语句看看时间： SELECT id,username,email,password FROM test_user WHERE id=9999987 因为建表时将id设为了主键，所以在根据id查找时用了主键索引，所以速度很快。 我们再来执行SELECT id,username,email,password FROM test_user WHERE username=’username_9000000’耗时：4.613s。 Extra显示数据库运用了全表扫描所以速度慢，我们把username列加上索引试试。运行:ALTER TABLE test_user ADD INDEX index_name(username)。 我不知道为什么我的索引加的贼慢，老大说这个跟硬件、数据库版本等都有关系，可能是公司电脑不好吧，正常二三百秒应该就可以了，接下来再根据用户名来进行查询:select id,username,email,password from test_user where username=’username_9000000’。 结果仅用了0.02S相对于加索引前的4.61S快了将近230倍！！！我们再用Extra分析看看: EXPLAIN SELECT * from test_user where username=’username_9999999’ Extra显示，我们的本次查询使用了username的索引，仅扫描了将近5000行便查询出了结果，查询速度得到了质的提升。 再来试试用两个条件联合查询:SELECT * FROM test_user WHERE password = ‘1dfb5fe87af0d26015808b2a431360a6’ AND username = ‘username_9999014’。 运行结果0.027S，根据Extra显示，我们使用了索引搜索。说明数据库会优先匹配索引来进行查找。 我们再执行:SELECT * FROM test_user WHERE password = ‘41c3d2dc43de0e942f43000f0767cf95’ OR username = ‘username_9999015’，虽然我们对username列加了索引，但是password列没有加，当索引执行password的搜索时，就会进行全表搜索速度变慢。 可以看到OR语句搜索时没有使用索引，而是进行了全表搜索，搜索速度下降很多。AND语句才会使用聚合索引，要符合最左原则。 小结： 合理使用索引可以极大加快查询速度 sql编写过程中慎用OR条件","path":"2019/03/04/MySQL中利用索引优化/"}]}